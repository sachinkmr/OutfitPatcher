using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using Noggog;
using System.IO;
using Code.OutfitPatcher.Utils;
using Code.OutfitPatcher.Config;
using Mutagen.Bethesda.Environments;
using Mutagen.Bethesda.Plugins.Cache;
using log4net;
using Code.OutfitPatcher.Managers;
using Mutagen.Bethesda.Plugins;

namespace Code.OutfitPatcher
{
    public class SynPoint
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(SynPoint));
        internal static IGameEnvironment<ISkyrimMod, ISkyrimModGetter> PatcherEnv = GameEnvironment.Typical.Skyrim(
                SkyrimRelease.SkyrimSE, LinkCachePreferences.Default);

        internal static Settings Settings = null;
        static Lazy<Settings> LazySettings = null!;
        public static ISkyrimMod Patch;

        public static async Task<int> Start(string[] args)
        {
            //CustomHelper.MoveMods("E:\\Modded\\SSE\\MoveMods.txt", "E:\\Modded\\SSE\\AlderOld\\Aldrnari\\mods", "E:\\Modded\\SSE\\Aldrnari\\mods");
            //CustomHelper.ShowOptionalPlugins("E:\\Modded\\SSE\\MoveMods.txt", "E:\\Modded\\SSE\\Aldrnari\\mods");
            
            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings(nickname: "Settings",
                    path: "settings.json", out LazySettings, true)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(InitSettings)               
                .SetTypicalOpen(GameRelease.SkyrimSE, "NPC Armor Distributor - Delete Me.esp")
                .Run(args);
        }

        public static void InitSettings(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            Settings = LazySettings.Value;
            Settings.Init(state);
            PatcherEnv.Dispose();
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            state.LoadOrder.Keys.ForEach(k =>
            {
                if (k.Name.StartsWith(Settings.Patcher.PatcherPrefix))
                    state.LoadOrder.RemoveKey(k);
            });

            Settings = LazySettings.Value;
            Settings.Init(state);
            PatcherEnv.Dispose();
            Console.WriteLine("************ Starting Patcher ************");

            if (!RequirementsFullfilled(state)) return;

            var patchName = Settings.Patcher.PatcherPrefix + "Patch 1.esp";
            Patch = FileUtils.GetOrAddPatch(patchName);
            Patch = new OutfitManager(state).Process(Patch);
            Patch = new SleepingOutfitManager(state).Process(Patch);

            // Little house keeping 
            if (Settings.User.CreateBashPatch)
            {
                CreateBashPatchForLVLI(state, Patch);
                CreateBashPatchForLVLN(state, Patch);
            }

            //Saving all the patches to disk
            Console.WriteLine("\nSaving all the patches to disk...");
            Settings.Patches.ForEach(p => FileUtils.SaveMod(state, p));
            Console.WriteLine("Patching completed, Enjoy your game...\n\n");
        }

        private static void CreateBashPatchForLVLI(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ISkyrimMod patch)
        {
            Console.WriteLine("\nCreating Leveled List bash patch...");
            patch = FileUtils.GetIncrementedMod(patch);
            foreach (ILeveledItemGetter lvli in state.LoadOrder.PriorityOrder
                .WinningOverrides<ILeveledItemGetter>())
            {
                List<ILeveledItemGetter> lvlis = state.LinkCache.ResolveAll<ILeveledItemGetter>(lvli.FormKey).ToList();
                if (lvlis.Count > 1)
                {
                    List<LeveledItemEntry> entries = new();
                    lvlis.ForEach(x => entries.AddRange(x.Entries.EmptyIfNull().Select(entry => entry.DeepCopy())));
                    LeveledItem lvl = patch.LeveledItems.GetOrAddAsOverride(lvlis.First());
                    lvl.Entries = new ExtendedList<LeveledItemEntry>();
                    LeveledListUtils.AddEntriesToLeveledList(patch, lvl, entries);
                }
            }
        }

        private static void CreateBashPatchForLVLN(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ISkyrimMod patch)
        {
            Console.WriteLine("Creating Leveled NPC bash patch...");
            patch = FileUtils.GetIncrementedMod(patch);
            foreach (ILeveledNpcGetter lvli in state.LoadOrder.PriorityOrder
                .WinningOverrides<ILeveledNpcGetter>())
            {
                List<ILeveledNpcGetter> lvlis = Settings.Cache.ResolveAll<ILeveledNpcGetter>(lvli.FormKey).ToList();
                if (lvlis.Count > 1)
                {
                    List<LeveledNpcEntry> entries = new();
                    lvlis.ForEach(x => entries.AddRange(x.Entries.EmptyIfNull().Select(entry => entry.DeepCopy())));
                    LeveledNpc lvl = patch.LeveledNpcs.GetOrAddAsOverride(lvlis.First());
                    lvl.Entries = new();
                    LeveledListUtils.AddEntriesToLeveledList(patch, lvl, entries);
                }
            }
        }

        private static bool RequirementsFullfilled(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Validating requirements...");
            string spidLoc = Path.Combine(state.DataFolderPath, "skse", "plugins", "po3_SpellPerkItemDistributor.dll");
            if (!File.Exists(spidLoc))
            {
                Logger.ErrorFormat("Spell Perk Item Distributer mod is not found. Install it properly and re-run the patcher...");
                return false;
            }


            // Checking for JSOn File Categories
            var hasErrors = false;
            Settings.User.ArmorMods.ForEach(s =>
            {
                if (!s.Value.Any())
                {
                    Logger.ErrorFormat("{0} does not contains any category", s.Key);
                    hasErrors = true;
                }
                s.Value.ForEach(x =>
                {
                    if (x != "Generic" && !Settings.Patcher.Categories.Contains(x))
                    {
                        Logger.ErrorFormat("{0} contains invalid Category:{1}", s.Key, x);
                        hasErrors = true;
                    }
                });
            });

            Console.WriteLine("All the requirements are validated...");
            return !hasErrors;
        }
    }
}
